import mathimport numpy as npimport torchimport torch.nn as nnfrom utils import log_normal_density# from tensorboardX import SummaryWriter# writer = SummaryWriter('./log0919')onehot = np.eye(4)class SelfAttention(nn.Module):    def __init__(self):        super(SelfAttention, self).__init__()        self.projection = nn.Sequential(            nn.Linear(128*3, 128),            nn.ReLU(True),            nn.Linear(128, 3)        )    def forward(self, encoder_outputs):        # (B, L, H) -> (B , L*H)        input1=encoder_outputs        #print('1', input1.shape)  # torch.Size([1, 3, 128])        #print(encoder_outputs.shape[0])  1        feture = encoder_outputs.view(encoder_outputs.shape[0], -1)        # print('fet', feture.shape)  torch.Size([1, 384])        energy = self.projection(feture)        weights = torch.softmax(energy, dim=1)   # (1,3)        #print('www', (input1 * weights.unsqueeze(-1)).shape)  # (1,3,128)        # (B, L, H) * (B, L, 1) -> (B, H)        outputs = (input1 * weights.unsqueeze(-1)).sum(dim=1)        # print(outputs.shape)  torch.Size([1, 128])        return outputs, weightsclass VLnet(nn.Module):    def __init__(self, action_space):        super(VLnet, self).__init__()        self.logstd = nn.Parameter(torch.zeros(action_space))        self.act_fea_cv0 = nn.Conv1d(in_channels=1, out_channels=4, kernel_size=5, stride=2, padding=1)        self.act_fea_cv1 = nn.Conv1d(in_channels=4, out_channels=4, kernel_size=3, stride=2, padding=1)        self.act_fea_cv2 = nn.Conv1d(in_channels=1, out_channels=4, kernel_size=5, stride=2, padding=1)        self.act_fea_cv3 = nn.Conv1d(in_channels=4, out_channels=4, kernel_size=3, stride=2, padding=1)        self.act_fea_cv4 = nn.Conv1d(in_channels=1, out_channels=4, kernel_size=5, stride=2, padding=1)        self.act_fea_cv5 = nn.Conv1d(in_channels=4, out_channels=4, kernel_size=3, stride=2, padding=1)        self.act_fc1_left = nn.Linear(160, 128)        self.act_fc1_central = nn.Linear(160, 128)        self.act_fc1_right = nn.Linear(160, 128)        self.command_fc1 = nn.Linear(4, 128)        self.command_fc2 = nn.Linear(128, 128)        self.act_fc2 = nn.Linear(128, 128)        # self.act_fc3 = nn.Linear(128*2, 128)        # self.act_fc4 = nn.Linear(128, 128)        # self.act_fc5 = nn.Linear(128, 64)        ## follow lane        self.actor1 = nn.Linear(128, 128)        self.actor1_a = nn.Linear(128, 128)        self.actor1_v1 = nn.Linear(128, 128)        self.actor1_v2 = nn.Linear(128, 128)        self.actor1_s = nn.Linear(128, 1)        self.actor1_w = nn.Linear(128, 1)        self.critic1 = nn.Linear(128, 1)        ## turn left        self.actor2 = nn.Linear(128 , 128)        self.actor2_a = nn.Linear(128, 128)        self.actor2_v1 = nn.Linear(128, 128)	self.actor2_v2 = nn.Linear(128, 128)        self.actor2_s = nn.Linear(128, 1)        self.actor2_w = nn.Linear(128, 1)        self.critic2 = nn.Linear(128, 1)        ## turn right        self.actor3 = nn.Linear(128, 128)        self.actor3_a = nn.Linear(128, 128)        self.actor3_v1 = nn.Linear(128, 128)        self.actor3_v2 = nn.Linear(128, 128)        self.actor3_s = nn.Linear(128, 1)        self.actor3_w = nn.Linear(128, 1)        self.critic3 = nn.Linear(128, 1)        ## go straight        self.actor4 = nn.Linear(128, 128)        self.actor4_a = nn.Linear(128, 128)        self.actor4_v1 = nn.Linear(128, 128)        self.actor4_v2 = nn.Linear(128, 128)        self.actor4_s = nn.Linear(128, 1)        self.actor4_w = nn.Linear(128, 1)        self.critic4 = nn.Linear(128, 1)        # self.actor1 = nn.Linear(64, 1)        # self.actor2 = nn.Linear(64, 1)        #        # self.crt_fc1 = nn.Linear(128, 128)        # self.crt_fc2 = nn.Linear(128, 64)        # self.critic = nn.Linear(64, 1)        self.attention = SelfAttention()    def forward(self, bottom_left ,bottom_central, bottom_right, command_input):        """            returns value estimation, action, log_action_prob        """        l0_left = torch.relu(self.act_fea_cv0(bottom_left))        l0_left = torch.relu(self.act_fea_cv1(l0_left))        l0_left = l0_left.view(l0_left.shape[0], -1)        l0_enctral = torch.relu(self.act_fea_cv2(bottom_central))        l0_enctral = torch.relu(self.act_fea_cv3(l0_enctral))        l0_enctral = l0_enctral.view(l0_enctral.shape[0], -1)        l0_right = torch.relu(self.act_fea_cv4(bottom_right))        l0_right =  torch.relu(self.act_fea_cv5(l0_right))        l0_right = l0_right.view(l0_right.shape[0], -1)        l1_left = torch.relu(self.act_fc1_left(l0_left)).unsqueeze(dim=1)        l1_central = torch.relu(self.act_fc1_central(l0_enctral)).unsqueeze(dim=1)        l1_right = torch.relu(self.act_fc1_right(l0_right)).unsqueeze(dim=1)        a = torch.cat((l1_left, l1_central, l1_right), dim=1)        feature, weights = self.attention(a)        a1 = torch.relu(self.act_fc2(feature))        #command_input1 = torch.relu(self.command_fc1(command_input))        #command_input2 = torch.relu(self.command_fc2(command_input1))        com = command_input[0].data.cpu().numpy()        if (com == np.asarray([1,0,0,0])).all():   # follow lane            branch1 = torch.relu(self.actor1(a1))             # 128 --> 128            branch11 = torch.relu(self.actor1_a(branch1))     # 128            mean1 = torch.sigmoid(self.actor1_s(branch11))            mean2 = torch.tanh(self.actor1_w(branch11))            branchv = torch.relu(self.actor1_v1(a1))            branchv1 = torch.relu(self.actor1_v2(branchv))            v = self.critic1(branchv1)        if (com == np.asarray([0,1,0,0])).all():   # turn left            branch2 = torch.relu(self.actor2(a1))  # 128 --> 128            branch22 = torch.relu(self.actor2_a(branch2))  # 128            mean1 = torch.sigmoid(self.actor2_s(branch22))            mean2 = torch.tanh(self.actor2_w(branch22))	                branch2v = torch.relu(self.actor2_v1(a1))            branch22v = torch.relu(self.actor2_v2(branch2v))            v = self.critic2(branch22v)        if (com == np.asarray([0, 0, 1, 0])).all():  # turn right            branch3 = torch.relu(self.actor3(a1))  # 128 --> 128            branch33 = torch.relu(self.actor3_a(branch3))  # 128            mean1 = torch.sigmoid(self.actor3_s(branch33))            mean2 = torch.tanh(self.actor3_w(branch33))                        branch3v = torch.relu(self.actor3_v1(a1))            branch33v = torch.relu(self.actor3_v2(branch3v))            v = self.critic3(branch33v)        if (com == np.asarray([0, 0, 0, 1])).all():   # go straight            branch4 = torch.relu(self.actor4(a1))  # 128 --> 128            branch44 = torch.relu(self.actor4_a(branch4))  # 128            mean1 = torch.sigmoid(self.actor4_s(branch44))            mean2 = torch.tanh(self.actor4_w(branch44))            branch4v = torch.relu(self.actor4_v1(a1))            branch44v = torch.relu(self.actor4_v2(branch4v))            v = self.critic4(branch44v)        # a2 = torch.cat((a1,command_input2), dim=-1)        # a3 = torch.relu(self.act_fc3(a2))        # a4 = torch.relu(self.act_fc4(a3))        # a5 = torch.relu(self.act_fc5(a4))        # mean1 = torch.sigmoid(self.actor1(a5))        # mean2 = torch.tanh(self.actor2(a5))        # c1 = torch.relu(self.crt_fc1(a3))        # c2 = torch.relu(self.crt_fc2(c1))        # v = self.critic(c2)        mean = torch.cat((mean1, mean2), dim=-1)        logstd = self.logstd.expand_as(mean)        std = torch.exp(logstd)        action = torch.normal(mean, std)		#writer.add_scalar('mean_speed',mean[0][0])	#writer.add_scalar('mean_steering',mean[0][1])	#writer.add_scalar('std_speed',std[0])	#writer.add_scalar('std_steering',std[1])       #print(mean, std,action)	#print(weights)        # action prob on log scale        logprob = log_normal_density(action, mean, std=std, log_std=logstd)        return v, action, logprob, mean,weights    def evaluate_actions(self, bottom_left ,bottom_central, bottom_right,command_input, action):        v, _, _, mean, weights = self.forward(bottom_left ,bottom_central, bottom_right ,command_input)        logstd = self.logstd.expand_as(mean)        std = torch.exp(logstd)        # evaluate        logprob = log_normal_density(action, mean, log_std=logstd, std=std)        dist_entropy = 0.5 + 0.5 * math.log(2 * math.pi) + logstd        dist_entropy = dist_entropy.sum(-1).mean()        return v, logprob, dist_entropyif __name__ == '__main__':    vl = VLnet(action_space=2)    l = torch.ones(1,160)    #print(l)    c = torch.ones(1,160)    r = torch.ones(1,160)    command = torch.ones(1,4)    #print(command)    vl(l,c,r,command)